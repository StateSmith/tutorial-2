// Autogenerated with StateSmith 0.9.9-alpha.
// Algorithm: Balanced1. See https://github.com/StateSmith/StateSmith/wiki/Algorithms

// Whatever you put in the IRenderConfig.FileTop section ends up at the top of the file.
#nullable enable

using System; // User `using` specified in `IRenderConfigCSharp.Usings`

namespace LightController;

// Generated state machine
public class LightSm : LightSmBase
{
    public enum EventId
    {
        DIM = 0,
        INCREASE = 1,
        OFF = 2,
    }

    public const int EventIdCount = 3;

    public enum StateId
    {
        ROOT = 0,
        OFF = 1,
        ON_GROUP = 2,
        ON_HOT = 3,
        ON1 = 4,
        ON2 = 5,
    }

    public const int StateIdCount = 6;

    // event handler type
    private delegate void Func(LightSm sm);

    // Used internally by state machine. Feel free to inspect, but don't modify.
    public StateId stateId;

    // Used internally by state machine. Don't modify.
    private Func? ancestorEventHandler;

    // Used internally by state machine. Don't modify.
    private readonly Func?[] currentEventHandlers = new Func[EventIdCount];

    // Used internally by state machine. Don't modify.
    private Func? currentStateExitHandler;

    // State machine constructor. Must be called before start or dispatch event functions. Not thread safe.
    public LightSm()
    {
    }

    // Starts the state machine. Must be called before dispatching events. Not thread safe.
    public void Start()
    {
        ROOT_enter();
        // ROOT behavior
        // uml: TransitionTo(ROOT.<InitialState>)
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.

            // Step 2: Transition action: ``.

            // Step 3: Enter/move towards transition target `ROOT.<InitialState>`.
            // ROOT.<InitialState> is a pseudo state and cannot have an `enter` trigger.

            // ROOT.<InitialState> behavior
            // uml: TransitionTo(OFF)
            {
                // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition). Already at LCA, no exiting required.

                // Step 2: Transition action: ``.

                // Step 3: Enter/move towards transition target `OFF`.
                OFF_enter();

                // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
                this.stateId = StateId.OFF;
                // No ancestor handles event. Can skip nulling `ancestorEventHandler`.
                return;
            } // end of behavior for ROOT.<InitialState>
        } // end of behavior for ROOT
    }

    // Dispatches an event to the state machine. Not thread safe.
    public void DispatchEvent(EventId eventId)
    {
        Func? behaviorFunc = this.currentEventHandlers[(int)eventId];

        while (behaviorFunc != null)
        {
            this.ancestorEventHandler = null;
            behaviorFunc(this);
            behaviorFunc = this.ancestorEventHandler;
        }
    }

    // This function is used when StateSmith doesn't know what the active leaf state is at
    // compile time due to sub states or when multiple states need to be exited.
    private void ExitUpToStateHandler(Func desiredStateExitHandler)
    {
        while (this.currentStateExitHandler != desiredStateExitHandler)
        {
            this.currentStateExitHandler!(this);
        }
    }


    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state ROOT
    ////////////////////////////////////////////////////////////////////////////////

    private void ROOT_enter()
    {
        // setup trigger/event handlers
        this.currentStateExitHandler = ptr_ROOT_exit;
    }

    // static delegate to avoid implicit conversion and garbage collection
    private static readonly Func ptr_ROOT_exit = (LightSm sm) => sm.ROOT_exit();
    private void ROOT_exit()
    {
    }


    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state OFF
    ////////////////////////////////////////////////////////////////////////////////

    private void OFF_enter()
    {
        // setup trigger/event handlers
        this.currentStateExitHandler = ptr_OFF_exit;
        this.currentEventHandlers[(int)EventId.INCREASE] = ptr_OFF_increase;

        // OFF behavior
        // uml: enter / { Console.WriteLine("OFF"); }
        {
            // Step 1: execute action `Console.WriteLine("OFF");`
            Console.WriteLine("OFF");
        } // end of behavior for OFF
    }

    // static delegate to avoid implicit conversion and garbage collection
    private static readonly Func ptr_OFF_exit = (LightSm sm) => sm.OFF_exit();
    private void OFF_exit()
    {
        // adjust function pointers for this state's exit
        this.currentStateExitHandler = ptr_ROOT_exit;
        this.currentEventHandlers[(int)EventId.INCREASE] = null;  // no ancestor listens to this event
    }

    // static delegate to avoid implicit conversion and garbage collection
    private static readonly Func ptr_OFF_increase = (LightSm sm) => sm.OFF_increase();
    private void OFF_increase()
    {
        // No ancestor state handles `increase` event.

        // OFF behavior
        // uml: INCREASE TransitionTo(ON1)
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
            OFF_exit();

            // Step 2: Transition action: ``.

            // Step 3: Enter/move towards transition target `ON1`.
            ON_GROUP_enter();
            ON1_enter();

            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            this.stateId = StateId.ON1;
            // No ancestor handles event. Can skip nulling `ancestorEventHandler`.
            return;
        } // end of behavior for OFF
    }


    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state ON_GROUP
    ////////////////////////////////////////////////////////////////////////////////

    private void ON_GROUP_enter()
    {
        // setup trigger/event handlers
        this.currentStateExitHandler = ptr_ON_GROUP_exit;
        this.currentEventHandlers[(int)EventId.OFF] = ptr_ON_GROUP_off;
    }

    // static delegate to avoid implicit conversion and garbage collection
    private static readonly Func ptr_ON_GROUP_exit = (LightSm sm) => sm.ON_GROUP_exit();
    private void ON_GROUP_exit()
    {
        // adjust function pointers for this state's exit
        this.currentStateExitHandler = ptr_ROOT_exit;
        this.currentEventHandlers[(int)EventId.OFF] = null;  // no ancestor listens to this event
    }

    // static delegate to avoid implicit conversion and garbage collection
    private static readonly Func ptr_ON_GROUP_off = (LightSm sm) => sm.ON_GROUP_off();
    private void ON_GROUP_off()
    {
        // No ancestor state handles `off` event.

        // ON_GROUP behavior
        // uml: OFF TransitionTo(OFF)
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
            ExitUpToStateHandler(ptr_ROOT_exit);

            // Step 2: Transition action: ``.

            // Step 3: Enter/move towards transition target `OFF`.
            OFF_enter();

            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            this.stateId = StateId.OFF;
            // No ancestor handles event. Can skip nulling `ancestorEventHandler`.
            return;
        } // end of behavior for ON_GROUP
    }


    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state ON_HOT
    ////////////////////////////////////////////////////////////////////////////////

    private void ON_HOT_enter()
    {
        // setup trigger/event handlers
        this.currentStateExitHandler = ptr_ON_HOT_exit;
        this.currentEventHandlers[(int)EventId.DIM] = ptr_ON_HOT_dim;

        // ON_HOT behavior
        // uml: enter / { LightRed(); }
        {
            // Step 1: execute action `LightRed();`
            LightRed();
        } // end of behavior for ON_HOT
    }

    // static delegate to avoid implicit conversion and garbage collection
    private static readonly Func ptr_ON_HOT_exit = (LightSm sm) => sm.ON_HOT_exit();
    private void ON_HOT_exit()
    {
        // adjust function pointers for this state's exit
        this.currentStateExitHandler = ptr_ON_GROUP_exit;
        this.currentEventHandlers[(int)EventId.DIM] = null;  // no ancestor listens to this event
    }

    // static delegate to avoid implicit conversion and garbage collection
    private static readonly Func ptr_ON_HOT_dim = (LightSm sm) => sm.ON_HOT_dim();
    private void ON_HOT_dim()
    {
        // No ancestor state handles `dim` event.

        // ON_HOT behavior
        // uml: DIM TransitionTo(ON2)
        {
            // Step 1: Exit states until we reach `ON_GROUP` state (Least Common Ancestor for transition).
            ON_HOT_exit();

            // Step 2: Transition action: ``.

            // Step 3: Enter/move towards transition target `ON2`.
            ON2_enter();

            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            this.stateId = StateId.ON2;
            // No ancestor handles event. Can skip nulling `ancestorEventHandler`.
            return;
        } // end of behavior for ON_HOT
    }


    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state ON1
    ////////////////////////////////////////////////////////////////////////////////

    private void ON1_enter()
    {
        // setup trigger/event handlers
        this.currentStateExitHandler = ptr_ON1_exit;
        this.currentEventHandlers[(int)EventId.DIM] = ptr_ON1_dim;
        this.currentEventHandlers[(int)EventId.INCREASE] = ptr_ON1_increase;

        // ON1 behavior
        // uml: enter / { LightBlue(); }
        {
            // Step 1: execute action `LightBlue();`
            LightBlue();
        } // end of behavior for ON1
    }

    // static delegate to avoid implicit conversion and garbage collection
    private static readonly Func ptr_ON1_exit = (LightSm sm) => sm.ON1_exit();
    private void ON1_exit()
    {
        // adjust function pointers for this state's exit
        this.currentStateExitHandler = ptr_ON_GROUP_exit;
        this.currentEventHandlers[(int)EventId.DIM] = null;  // no ancestor listens to this event
        this.currentEventHandlers[(int)EventId.INCREASE] = null;  // no ancestor listens to this event
    }

    // static delegate to avoid implicit conversion and garbage collection
    private static readonly Func ptr_ON1_dim = (LightSm sm) => sm.ON1_dim();
    private void ON1_dim()
    {
        // No ancestor state handles `dim` event.

        // ON1 behavior
        // uml: DIM TransitionTo(OFF)
        {
            // Step 1: Exit states until we reach `ROOT` state (Least Common Ancestor for transition).
            ExitUpToStateHandler(ptr_ROOT_exit);

            // Step 2: Transition action: ``.

            // Step 3: Enter/move towards transition target `OFF`.
            OFF_enter();

            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            this.stateId = StateId.OFF;
            // No ancestor handles event. Can skip nulling `ancestorEventHandler`.
            return;
        } // end of behavior for ON1
    }

    // static delegate to avoid implicit conversion and garbage collection
    private static readonly Func ptr_ON1_increase = (LightSm sm) => sm.ON1_increase();
    private void ON1_increase()
    {
        // No ancestor state handles `increase` event.

        // ON1 behavior
        // uml: INCREASE TransitionTo(ON2)
        {
            // Step 1: Exit states until we reach `ON_GROUP` state (Least Common Ancestor for transition).
            ON1_exit();

            // Step 2: Transition action: ``.

            // Step 3: Enter/move towards transition target `ON2`.
            ON2_enter();

            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            this.stateId = StateId.ON2;
            // No ancestor handles event. Can skip nulling `ancestorEventHandler`.
            return;
        } // end of behavior for ON1
    }


    ////////////////////////////////////////////////////////////////////////////////
    // event handlers for state ON2
    ////////////////////////////////////////////////////////////////////////////////

    private void ON2_enter()
    {
        // setup trigger/event handlers
        this.currentStateExitHandler = ptr_ON2_exit;
        this.currentEventHandlers[(int)EventId.DIM] = ptr_ON2_dim;
        this.currentEventHandlers[(int)EventId.INCREASE] = ptr_ON2_increase;

        // ON2 behavior
        // uml: enter / { LightYellow(); }
        {
            // Step 1: execute action `LightYellow();`
            LightYellow();
        } // end of behavior for ON2

        // ON2 behavior
        // uml: enter / { count = 0; }
        {
            // Step 1: execute action `count = 0;`
            count = 0;
        } // end of behavior for ON2
    }

    // static delegate to avoid implicit conversion and garbage collection
    private static readonly Func ptr_ON2_exit = (LightSm sm) => sm.ON2_exit();
    private void ON2_exit()
    {
        // adjust function pointers for this state's exit
        this.currentStateExitHandler = ptr_ON_GROUP_exit;
        this.currentEventHandlers[(int)EventId.DIM] = null;  // no ancestor listens to this event
        this.currentEventHandlers[(int)EventId.INCREASE] = null;  // no ancestor listens to this event
    }

    // static delegate to avoid implicit conversion and garbage collection
    private static readonly Func ptr_ON2_dim = (LightSm sm) => sm.ON2_dim();
    private void ON2_dim()
    {
        // No ancestor state handles `dim` event.

        // ON2 behavior
        // uml: DIM TransitionTo(ON1)
        {
            // Step 1: Exit states until we reach `ON_GROUP` state (Least Common Ancestor for transition).
            ON2_exit();

            // Step 2: Transition action: ``.

            // Step 3: Enter/move towards transition target `ON1`.
            ON1_enter();

            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            this.stateId = StateId.ON1;
            // No ancestor handles event. Can skip nulling `ancestorEventHandler`.
            return;
        } // end of behavior for ON2
    }

    // static delegate to avoid implicit conversion and garbage collection
    private static readonly Func ptr_ON2_increase = (LightSm sm) => sm.ON2_increase();
    private void ON2_increase()
    {
        // No ancestor state handles `increase` event.

        // ON2 behavior
        // uml: 1. INCREASE / { count++; }
        {
            // Step 1: execute action `count++;`
            count++;

            // Step 2: determine if ancestor gets to handle event next.
            // No ancestor handles event. Can skip nulling `ancestorEventHandler`.
        } // end of behavior for ON2

        // ON2 behavior
        // uml: 2. INCREASE [count >= 3] TransitionTo(ON_HOT)
        if (count >= 3)
        {
            // Step 1: Exit states until we reach `ON_GROUP` state (Least Common Ancestor for transition).
            ON2_exit();

            // Step 2: Transition action: ``.

            // Step 3: Enter/move towards transition target `ON_HOT`.
            ON_HOT_enter();

            // Step 4: complete transition. Ends event dispatch. No other behaviors are checked.
            this.stateId = StateId.ON_HOT;
            // No ancestor handles event. Can skip nulling `ancestorEventHandler`.
            return;
        } // end of behavior for ON2
    }

    // Thread safe.
    public static string StateIdToString(StateId id)
    {
        switch (id)
        {
            case StateId.ROOT: return "ROOT";
            case StateId.OFF: return "OFF";
            case StateId.ON_GROUP: return "ON_GROUP";
            case StateId.ON_HOT: return "ON_HOT";
            case StateId.ON1: return "ON1";
            case StateId.ON2: return "ON2";
            default: return "?";
        }
    }

    // Thread safe.
    public static string EventIdToString(EventId id)
    {
        switch (id)
        {
            case EventId.DIM: return "DIM";
            case EventId.INCREASE: return "INCREASE";
            case EventId.OFF: return "OFF";
            default: return "?";
        }
    }
}
